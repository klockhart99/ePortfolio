## Code Review

## Video

<div style="text-align: center;">
    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
        <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube-nocookie.com/embed/yGJngI9px6M?rel=0" title="Code Review" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>
    <p><em>Code Review Video</em></p>
</div>

## Transcript
The transcript is based off the YouTube CC feature, do note it is not perfect but is mostly accurate to that of the video.

### Introduction
Hello, my name is Kenneth Lockhart, I am a computer science major who has spent around five years studying computer science. Additionally, over the last few years I have been working with databases and data analysis for the last three years at my place of employment today. Specifically, I'm going to be conducting a code review on two projects from my last year to two years here at SNHU. These two code reviews will be divided into three categories, software design and engineering, algorithms and data structures, and lastly databases. Since I am using one project for two categories I will describe and analyze that project only once. To break it down I will be using my event planner program from CS 360 for the first two categories and I will use my animal shelter database from CS340. Additionally, I will provide relative enhancements based on my analysis of each category and how they relate to one of the five outcomes that it supports. We will be starting by analyzing the code from the event planner, but it is important first to see how the program functions before we break it down into its code. 

### Artifact 1 and 2 Overview
Starting with the launch of the application, as you can see on the screen here you will be presented with a login screen immediately. This is used to help keep details of the events private and user specific. For this review we will be registering a new account and using that for the remainder of this example. Once registered we will be able to log in and be met with our upcoming events of course. With this being a new account we have no events registered but we can change that with the plus sign in the bottom right corner. Here we can make a simple event called “test” with a description “test event”. Our start date will be today, and we'll set a time of about 10 minutes from now. The end date we will set as the same as today and the end time will be about an hour from now.

You will notice upon saving an event that it will tell you that you need to add SMS permission for reminders. This we will get to towards the end of our demo. Upon saving you will see that the event has now been registered in our upcoming events. You can also now see that you can edit and/or delete an event from this menu as well editing an event will bring up the same details as when you added the event, just filling in the blanks rather than being completely empty. 

Another feature of this application is that we have a calendar view as seen in the bottom menu bar. By heading over there you can see that the calendar is presented along with the event for today. Below we can click on other days and see that we have no other events planned but upon clicking on a different day such as the 20th we can hit the plus sign, and we will see that the date is already pre-filled in for us to add a new event. We will make an event called “test two” and “test event” just as we did before, and we will go ahead and save that. Upon saving we notice immediately that our upcoming events does not show our event, that is because this event is decently into the future and isn't relative at this time. If we go back to our calendar tab and we look at the 20th we can see that an event does in fact exist.

Diving a little deeper into the application we also have a side menu bar in addition to the lower menu bar. This side menu bar allows us to return away from the side menu bar, access our settings, and/or log out. Looking at our settings here we can see that it's rather generic, but it allows us to give permission for SMS notifications and they also allow us to delete our data. If we wish to use the delete function will delete everything related to the user in one go following that we will log out and see that we return to the main screen.

### Artifact 1 and 2 Code Review
Moving directly into the actual code analysis itself we have a few things that will make this step a little simpler for the sake of simplification with our code analysis. We will take each screen as a snippet and look at them individually. This aligns also with how the application is set up as it is split into Java classes for each screen and/or fragment. For the sake of simplification with our code analysis we will be taking the code screen by screen fragment by fragment as that is how in the code it is divided up. Each screen is its own Java class same with its own fragment is its own Java class this will make it simpler to do our code review for the sake of this code review we will be looking in depth at a lot of these classes. However, some of these classes do not have all the features that you would expect to be reviewed. An example of this will be many classes do not contain any sort of loops so they will automatically pass any tests that would involve a loop. For example, in other words if the code does not use a feature, it is assumed that the feature passes and will not be discussed for the remainder of the of the review.

#### Login Screen Review 
With the general layout of this code review addressed we will start by looking at our main screen. In the case of the main screen this screen is our login screen of the application. Taking a look at the class as a brief overview just looking at the structure, we can see that it seems to follow a general Java structure. Looking at the structure of our main class here we can see that it is structured very similar to most Java projects we can see some key details such as private variables. We can see some public variables various functions in addition taking a look at these we can see that these variables and functions are all named in a conventional standard of camel case. Additionally, as we take a look at the code here throughout the file, we can see that it remains relatively consistent it has no glaring changes in its format or style. It is very consistently formatted with a tab every time there's a curly brace for example. Additionally, upon looking at the code we don't see anything that jumps out to say that the code is going to get stuck or trapped. Additionally, there's no additional commented out features or functions throughout the code, it seems all very concise and in one structural format. Additionally as we looked through our code here, we didn't notice anything for documentation that seemed to be missing, all the functions contained a Java documentation which was standard with Java. Likewise, all of our comments are consistent with the code they make sense with the code. For example, looking at our create function we can see that our first few variable assignments are very clear at what they do. Looking at user logged in you could see that it clearly creates a username when the screen is generated. 

Taking a look a little deeper into our variables, here we can see that all of our variables appear to be properly defined. For example, our database is a private object within our main class, that makes sense for the type of variable it is. Looking throughout our file here as we look at our arithmetic operations, we notice that there is none really within this file. The only sort of operation performed is a check to see if something is equal to each other. There is no decrementing of a number, no increasing of a number, and no use of floating point numbers. Likewise there's no use of division to worry about dividing by zero. 

Taking a look at loops and branches within this file we can see that there are no loops, there's no form of loop within this file however there is branching. There are branches checking for if the username or password are blank. Likewise, there's also a check to see if a user is validated so that way they can log into the home screen. During these checks there is no missing if statement or check that should be used. Although there is consideration that the username and password could be checked separately, however in this instance they are just checked together. Taking a look a little further into our if statement here the same applies to the register listener. Looking further into our file we can also see that the register listener has similar calls to that of the login listener. It also checks for the username and password to be filled in and it will also check to see if the username is found. Likewise, a similar split between username and password could be made for register as well. Which also brings up an important point to note that the if statement checking to see if the username and password fields are filled in could be its own function that checks for if that's true or not and returns. 

Taking a look at some defensive programming specifically in this file there's nothing that is clear defensive programming. Everything here is just generally good programming, we can see that all our variables are assigned and our inputs are checked. Additionally, while it's not checked here the database would be checked to see if it was created before the object was assigned. With that our main function and class is complete thus we will move on to our home screen as that is instantly where we are brought upon logging in.

#### Home Screen Review
As we take a look at our home screen, here we can see similar structure to that of the main class. We also have our documentation like our main class. Additionally, looking deeper into this as we're seeing some of our variable names scroll by. Here our variable names seem also to follow a consistent naming scheme, additionally looking at this, our comments our documentation as stated before all seem very clear, consistent and well-structured throughout the file. Taking a look at our loops and branches in this file we once again don't have any loops, we do still have some if statements which have some functions that we should address. 

Within them taking a look at our sidebar menu listener here we can see that it checks for if the item that was selected is the settings or the log out button, however it never checks to see if the return button is pressed. As a result, that means that the return button falls through the if statement running the final bit of code which is our set the sidebar invisible this could be a potential for a problem if we don't want all buttons to have that functionality. For example, if we made a new button that was for making groups for example within the event planner and it was tied to this menu if you were to click that button without it being assigned it will just treat it as a return button. This could be desired functionality, but this could also lead to problems down the road. If we take a look at our bottom menu, we can also see that a similar problem occurs with those events, however if the else statement is triggered nothing would happen. 

Taking a look at some defensive programming within this file results in the same kind of result as the main file. For example, all inputs are checked in some capacity against what they should be there's no use of user input that may cause issues within the program aside from potentially undesired closing of a menu or a button acting as a return button. As part of the home screen there are fragments contained within it tied specifically to the bottom menu. 

#### Upcoming Events Fragment Review
Taking a look at those fragments we can see that there are two key fragments within this file, one for upcoming events and one for the calendar fragment. Starting with the upcoming events fragment we can see that there's a difference between that of the home screen or the main screen. However, looking at the overall structure we can see very similar naming schemes formats and structure to that of previous. Additionally, as we take our look through here, we can see a few minor differences in formatting, however most of that is due to how the resources are declared versus the coding practice. This sort of difference in how the variables are named could be considered confusing and probably should be updated to following the same standard. Taking a look as we are going through here as well, we can see that the documentation is quite a bit more filled in than previously. You can tell by the number of comments that this file is somewhat more complex than others. 

This is also our first file that contains a while loop, our while loop in this case is checking to see if the cursor has a place to move to next. The cursor in this instance is coming from the database which is getting all the events of the current logged in user. Additionally, this loop is protected by an if statement that checks to make sure that the cursor actually has a starting location and can move to the next value. This check is required because it would create an error should the user have no events during this while loop. We can see that it is getting data from the database for the events that are in question. We can see that it is getting the end date, end time, start date, and start time. We can see that it also generates a formatter for making sure that the date is in the correct format for displaying. Additionally during this while loop in order to ensure that no errors occur during our data processing we have a try catch statement which is helping to protect against it crashing. Specifically avoiding a crash related to potentially incorrect or incorrectly formatted data within the database. This is more of a safety precaution than it is anything else. Getting to the end of the loop we can see that everything is double checked before adding it to the list for the recycler view. That check is handled at the bottom of our for loop where the if username is correct and the before end date and after the limiter date is checked. In the case of checking for loop termination this loop does not modify the cursor in any way within itself thus the loop will always terminate when it runs out of values in the cursor.

There are some key defensive programming techniques used within this file that should be considered for our code review. In our store data in arrays function here in order to ensure that there isn't any strange ids, events or anything within our recycler view we ensure that the arrays are cleared before asking the database to update them or replace data. This prevents unwanted data from being within our arrays. Additionally, another defensive programming technique is our try catch loop within our while loop this ensures that data is not misplaced within those arrays. Additionally, this also means that all our data is validated before it gets pushed to our recycling view.

#### Calendar Fragment Review
Moving on to our calendar fragment many of the same properties apply to the calendar as it does to the upcoming events. As we take a look at our calendar fragment, we can tell immediately it has the same issues as well as the same good aspects as the upcoming events fragment. We can see a similar variable naming issue with the camel case and the underscores. Additionally, upon looking through here we can see that the documentation still follows a solid amount of documentation and as we scroll through our code, we can see similarities between our calendar and upcoming events, especially in the update recycler view and our store data in arrays. 
Once again, we do have a loop within this function the loop follows the same practices as the previous loop in fact it's actually identical to that loop which brings us to a point in our structure. There could be a potential that we could have reused our store data in arrays function however the issue with that is how fragments are created. We would have to extend one of them to another which could result in problems within the within the program however we could have found a way to store them differently that would allow us to reuse this function. 

In terms of defensive programming the same rules apply as the previous. As part of those fragments a custom adapter class was created to help with creating a good recycler view. 

#### Recycler Custom Adapter Review
Taking a look at the recycler view we see similar structure and design to previous classes specifically if we consider the main screen or the home screen. Additionally, documentation is provided for each of the functions along with nice comments for other locations that are more complex. 

Taking a look at our variable names, we can see that the problem between camel case and under using underscores has been solved here within this file. We can see that there are no loops just like most of our other main, home and screen classes, however looking at it from a branch perspective we can see that there are a few key branches within this file. 

Within this file we check to see if we are considering an upcoming event or a calendar fragment in those checks we update the corresponding recycler with the correct view. Something to note about some defensive programming within this file we can see that there is an unused variable within here and that is the end dates this end dates array will become a common problem throughout this code review as end dates are not really considered for anything within the program. However, aside from that in terms of defensive programming we can see that everything is assigned properly and we do in fact check our fragments for what class they are. Likewise, we don't we don't attempt to update a fragment that does not support the update recycler function.

#### Setting Screen and SMS Broadcaster Review
Taking a look at our final screen class here before we talk about our databases or SMS alert, we have our settings. Here our settings handles our SMS and post permission codes as well as handles the delete account, return home, and SMS buttons. Again looking at all previous screen structure everything here seems relatively normal however there is a small difference between this structure and previous structures. The main thing to note during this look through of this is that many of the calls and creation of stuff requires much more in-depth calls. For example, if we look at the alert builder or anything like that, it has a set title, a set message, and a set positive button. It's much more complicated however the structure does follow a nice format that makes sense of all those. Additionally documentation is well placed and listed throughout the entirety of the class. 

Taking a look at loops and branches within this class we can see that there's no loops to worry about here however there are branches. These branches are very important branches as they request permission from the user. As a result of this we have to ensure that our branches are handled correctly. In the case that the SMS permission button is clicked we're going to check to see if the user has permissions before we do anything. We check this by seeing if the permission is granted according to our package manager if it is we don't have to do anything. When the SMS button is clicked here if it doesn't have permission we need to request the user's permission. This will cause us to have to check to see if should we prompt for a permission and how should we ask that question. This is where the alert dialogue builder comes into meaning. This provides a prompt that allows the user to essentially give permission for a set permission code whether that's SMS or the post notifications and finally we check to see if that request was approved or not by stating whether or not the permission was granted or it was denied. Everything stated with those branches could also apply to defensive programming as it ensures that all the user input is checked and verified before granting any permissions. 

Finally, while we're on the topic of SMS we should take a look at our SMS alert, this extends a broadcast receiver. This class is rather simple so rather than reviewing it in the full structure, variable, everything method. We'll just take a look at the function that is essentially all this function does is it gets the event name and its description and prepares a notification. This notification will then be sent to the notification manager and eventually it will notify the user that an event is occurring. However, in the event that the permission is not granted to post the notification it will not post any notification. 

#### Database Review
Taking a look at our final two classes, which are our two database classes, it becomes apparent that these are much different than our screen or our fragments. Taking a look we can see that the structure follows our traditional Java styled formatting and our naming scheme for variables is also following the same standard in structure. Taking a look at each of our functions along with the extra comments you can see clearly that the functions are well defined and documented. Taking a look at loops and branches we actually don't have any within this file. The database itself does not have to check for a branch at all instead it just returns a true or false if it did something. Following that it is in the responsibility of the other classes to validate its response. 

Likewise with the event database we can see that it is essentially identical to that of the login database once again our documentation and variables are clearly defined and stated. However, there is something to note throughout this file. There are some cases where branching is used compared to that of the login database. For example when we are adding an event we check to see if the event was successfully added or not to inform the user in the instance both conditions of res is equal to -1 and not equal to negative 1 are considered. The same check can be said about updating the event. 

Some things to note about defensive programming between the two is that these databases are very locked down they can only be accessible through the functions that they provide as a result that means no input data could cause any conflicts with the SQL provided for the database. And with that we've concluded the overall analysis of our code.

####  Final Review Thoughts
Overall, nothing really jumps out as bad but also there's a few aspects that could be tweaked to make it better. As a result, I'm going to give this code review a pretty good with some improvements. Overall, something during our analysis that jumped out to me is specifically the end date as we were looking at our end date in a couple instances, we could see that it really didn't have much that it was doing.

#### Enhancements
This leads me to the enhancements that I would like to do for category one. Our first category here was our software and design. Given the analysis we could see that clearly something was intended for the end date function, however it is clearly missing and not complete. This is a glaring problem with the software engineering and design aspect of the program thus the proposed addition of a daily planner to use the end date functionality properly would be the best enhancement for this application. This would not only allow me to demonstrate some skills with my Java knowledge but my mobile development knowledge and SQL knowledge. These skills will allow me to reach the outcome of developing well-founded and innovative techniques skills and tools that follow the best practice practices of computing. Additionally, this will allow me to complete one of the goals for this project that was unable to be completed. 

Additionally, this project was also considered for category 2 which is algorithms and data structures clearly as part of the data structure the end date is missing its functionality. Essentially this data structure is just additional, it has no purpose, the plan would be to add the data from the data structure to the program in the form of the daily event planner as stated by category 1. This will use similar skills to that of the category 1 enhancement such as mobile development SQL and Java additionally and it will lead to a very similar outcome as category 1.

In summary, essentially both category one and two go hand-in-hand with each other. By adding this daily planner, we will have to add data structures to the design and engineering of the software. Which will then also require us to write algorithms such as updating a recycler or such as displaying the data correctly. 

### Artifact 3
Lastly, we come to category three which is focusing on databases for the code review related to category three. I chose to pick my animal shelter from CS340 due to this program being simpler and more focused on just the database aspect. I will be combining both the code along with images to display how everything works together, 
So, to begin let's start with the core program itself, the actual interface for the database, the animal shelter class, which provides CRUD based operations for the animal collection. In MongoDB CRUD stands for create, read, update, and delete. Therefore, CRUD is the core aspect of any database, the ability to create, to read, to update, or to delete. Those functions are important to how a database can function.

Looking into the code itself we can see that the animal shelter class is designed and structured in your typical Python format it is well commented and the functions follow a good naming scheme. Additionally as part of the functions we can see that some of them have optional parameters and some do not. 

Taking a look at the documentation we can see that every function has a statement above it describing what it does. Additionally, we have checks and identifiers in the comments to assist with identifying what is what. Taking a look also at the structure we can see that the formatting also matches that of typical Python coding standards. Taking a look at our variables that are present within our file we could see that all the variables are very well formatted and understandable. All of the main variables appear to use camel case which is following a generic standard of programming. In the cases where camel case is not used and all caps are used. We can see that those are clearly determined constants rather than actual variables which is a common practice in other languages such as Java.

Taking a look at loops and branches within our animal shelter class we can see that there are quite a few branches that are available. Taking a look at our create for an example we check to see if the data that we input is none. In the event that the data is none an exception is raised to inform the user that there was nothing to save and in fact this is true for all of our functions. We check to see if our input parameters are none for example in our update we check to see if the query or the update data is none before we do any operation. In the event of the update function, however if either are none we will raise the exception meanwhile the read and delete function will also check to see if the data is none. 

Looking at our defensive programming within our file we can see immediately that our create, update, read, and delete functions all have protections via error checking as in it'll make sure that the data going into the database is correct for the database. In the event that it isn't it informs the user that an update, or insert, or read, or delete query failed to process and why. This could be because the data was in the incorrect format. 

Taking a look at our actual project file here that generates a dashboard as seen in the images provided, we could see that we import a bunch of information from juniper dash which is what the dashboard was built upon. As part of this you can also see that we have declared our username and password within here which under normal circumstances would be considered bad practice. Ideally the user should provide those independent of the file. Looking at the overall structure of the file we could see that there is a bunch of HTML calls and different various calls related to HTML which structures it very differently than our Python file. For the animal shelter throughout here it becomes very clear that the documentation is well spaced out and allows for quick and easy understanding of the structure of the file. As well as giving us an idea of what is going on looking at our variables here as I mentioned username and password should ideally not be stored and be provided by the user upon logging in. However, for the sake of this project it was simpler to have it coded although perhaps that should be removed in the future. 

Looking at our loops and branches within this file there's very little to consider within here the only branch that is where we check to see what our filter is. In the case of our filter we check all our available button filters such as, water, the mountains, the disaster and then whether or not there is none. There's no instance that is missing or unchecked for. Additionally, to prevent early loading errors we do check to see if the data that it starts with is none so that way we do not run into any sort of style or graph problems. Likewise we ensure that the index is not none and that it is either zero or the index that is intended to be selected. 

For defensive programming we also check to see if we can actually render the map update in the event that we cannot we will print the error rather than just trying to display garbage. As part of the enhancement to this project this project was designed to work with MongoDB on a Linux operating system. The enhancement would be to move it to other platforms allowing it to reach out to a bigger audience. This enhancement would involve tweaking the code in such a way that it will also run on a Windows machine. As a result this will require an extensive knowledge of both Windows and Linux to ensure that all conditions are properly transferred between the two. Once again this seems to align with my previous outcomes for the course which is to demonstrate the ability to show well-founded techniques skills and tools in the computing practice. Additionally, it'll help to deliver an industry specific goal to the project. It could also be used to be considered to employ strategies for building collaborative environments that enable diverse audiences to support organizational decisions in the field of computer science.
